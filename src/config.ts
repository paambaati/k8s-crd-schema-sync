/**
 * Default configuration for CRD schema sync
 */

import type { SyncConfig, URLCRDSource } from './types';
import { cac } from 'cac';
import { version } from '../package.json';

const DEFAULT_SOURCES: Array<URLCRDSource> = [
  {
    type: 'url',
    id: 'kong',
    name: 'Kong Ingress Controller',
    url: 'https://raw.githubusercontent.com/Kong/charts/main/charts/kong/crds/custom-resource-definitions.yaml',
    group: 'configuration.konghq.com',
    enabled: true,
  },
];

const DEFAULT_CONFIG: SyncConfig = {
  sources: DEFAULT_SOURCES,
  targetRepo: 'datreeio/CRDs-catalog',
  targetBranch: 'main',
  prTitleTemplate: 'chore: sync {source} CRD schemas',
  prBodyTemplate: `## Automated CRD Schema Sync

This PR automatically updates JSON schemas for Kubernetes Custom Resource Definitions.

**Source**: {source}
**Schemas Updated**: {count}
**Timestamp**: {timestamp}

Generated by [\`k8s-crd-schema-sync\`](https://github.com/paambaati/k8s-crd-schema-sync)
`,
  dryRun: false,
  workDir: './schemas',
  verbose: false,
};

export type Command = 'dump' | 'download' | 'publish';

export interface CLIParsedResult {
  command: Command | undefined;
  config: Partial<SyncConfig>;
  showHelp: boolean;
  showVersion: boolean;
  context?: string;
  cli: ReturnType<typeof cac>;
}

export function getDefaultConfig(): SyncConfig {
  return { ...DEFAULT_CONFIG };
}

export function loadConfigFromEnv(): Partial<SyncConfig> {
  return {
    dryRun: process.env.CRD_SYNC_DRY_RUN === 'true',
    verbose: process.env.CRD_SYNC_VERBOSE === 'true',
    githubToken: process.env.GITHUB_TOKEN,
    workDir: process.env.CRD_SYNC_WORK_DIR || './schemas',
    targetRepo: process.env.CRD_SYNC_TARGET_REPO || 'datreeio/CRDs-catalog',
    targetBranch: process.env.CRD_SYNC_TARGET_BRANCH || 'main',
  };
}

export function mergeConfigs(base: SyncConfig, overrides: Partial<SyncConfig>): SyncConfig {
  return {
    ...base,
    ...overrides,
    sources: overrides.sources || base.sources,
  };
}

export function parseConfigFromCLI(args: Array<string>): CLIParsedResult {
  const cli = cac('crd-schema-sync');

  const result: CLIParsedResult = {
    command: undefined,
    config: {},
    showHelp: false,
    showVersion: false,
    context: undefined,
    cli,
  };

  cli.version(version);

  cli
    .command('dump [context]', 'Dump CRDs from a Kubernetes cluster')
    .usage('[context] [options]')
    .option('--verbose', 'Enable verbose logging')
    .option('-w, --work-dir <path>', 'Working directory for schemas')
    .example((name) => `  $ ${name} dump                    # Use current kubeconfig context`)
    .example((name) => `  $ ${name} dump my-cluster         # Use specific cluster context`)
    .example((name) => `  $ ${name} dump -w /tmp/schemas    # Save schemas to custom directory`)
    .action((context, options) => {
      result.command = 'dump';
      result.context = context;
      if (options.verbose) {
        result.config.verbose = true;
      }
      if (options.workDir) {
        result.config.workDir = options.workDir;
      }
    });

  cli
    .command('download', 'Download CRDs from configured sources')
    .usage('[options]')
    .option('--verbose', 'Enable verbose logging')
    .option('-w, --work-dir <path>', 'Working directory for schemas')
    .example((name) => `  $ ${name} download                  # Download from default sources`)
    .example((name) => `  $ ${name} download -w ./crd-schemas # Save to custom directory`)
    .example((name) => `  $ ${name} download --verbose        # Show detailed download progress`)
    .action((options) => {
      result.command = 'download';
      if (options.verbose) {
        result.config.verbose = true;
      }
      if (options.workDir) {
        result.config.workDir = options.workDir;
      }
    });

  cli
    .command('publish', 'Publish CRD schemas to target repository via PR')
    .usage('[options]')
    .option('--verbose', 'Enable verbose logging')
    .option('-d, --dry-run', 'Dry run mode (do not create PRs)')
    .option('-w, --work-dir <path>', 'Working directory for schemas')
    .option('-t, --target-repo <repo>', 'Target GitHub repository')
    .option('-b, --target-branch <name>', 'Target branch')
    .example(
      (name) =>
        `  $ ${name} publish --dry-run                       # Simulate publishing without creating any PRs`
    )
    .example(
      (name) =>
        `  $ ${name} publish -w ./schemas -t owner/repo      # Publish to custom repository on GitHub`
    )
    .example(
      (name) => `  $ ${name} publish -b main                         # Target specific branch`
    )
    .action((options) => {
      result.command = 'publish';
      if (options.verbose) {
        result.config.verbose = true;
      }
      if (options.dryRun !== undefined) {
        result.config.dryRun = options.dryRun;
      }
      if (options.workDir) {
        result.config.workDir = options.workDir;
      }
      if (options.targetRepo) {
        result.config.targetRepo = options.targetRepo;
      }
      if (options.targetBranch) {
        result.config.targetBranch = options.targetBranch;
      }
    });

  try {
    cli.parse(args, { run: true });
  } catch {}

  return result;
}
