/**
 * Default configuration for CRD schema sync
 */

import type { SyncConfig, URLCRDSource } from './types';
import { cac } from 'cac';
import { version } from '../package.json';

const DEFAULT_SOURCES: Array<URLCRDSource> = [
  {
    type: 'url',
    id: 'kong',
    name: 'Kong Ingress Controller',
    url: 'https://raw.githubusercontent.com/Kong/charts/main/charts/kong/crds/custom-resource-definitions.yaml',
    group: 'configuration.konghq.com',
    enabled: true,
  },
];

const DEFAULT_CONFIG: SyncConfig = {
  sources: DEFAULT_SOURCES,
  targetRepo: 'datreeio/CRDs-catalog',
  targetBranch: 'main',
  createPR: false,
  prTitleTemplate: 'chore: sync {source} CRD schemas',
  prBodyTemplate: `## Automated CRD Schema Sync

This PR automatically updates JSON schemas for Kubernetes Custom Resource Definitions.

**Source**: {source}
**Schemas Updated**: {count}
**Timestamp**: {timestamp}

Generated by [\`k8s-crd-schema-sync\`](https://github.com/paambaati/k8s-crd-schema-sync)
`,
  dryRun: false,
  outputDir: './schemas',
  verbose: false,
};

export type Command = 'dump' | 'download' | 'publish';

export interface CLIParsedResult {
  command: Command | undefined;
  config: Partial<SyncConfig>;
  showHelp: boolean;
  showVersion: boolean;
  context?: string;
  cli: ReturnType<typeof cac>;
}

export function getDefaultConfig(): SyncConfig {
  return { ...DEFAULT_CONFIG };
}

export function loadConfigFromEnv(): Partial<SyncConfig> {
  return {
    createPR: process.env.CRD_SYNC_CREATE_PR === 'true',
    dryRun: process.env.CRD_SYNC_DRY_RUN === 'true',
    verbose: process.env.CRD_SYNC_VERBOSE === 'true',
    githubToken: process.env.GITHUB_TOKEN,
    outputDir: process.env.CRD_SYNC_OUTPUT_DIR || './schemas',
    targetRepo: process.env.CRD_SYNC_TARGET_REPO || 'datreeio/CRDs-catalog',
    targetBranch: process.env.CRD_SYNC_TARGET_BRANCH || 'main',
  };
}

export function mergeConfigs(base: SyncConfig, overrides: Partial<SyncConfig>): SyncConfig {
  return {
    ...base,
    ...overrides,
    sources: overrides.sources || base.sources,
  };
}

export function parseConfigFromCLI(args: Array<string>): CLIParsedResult {
  const cli = cac('crd-schema-sync');

  const result: CLIParsedResult = {
    command: undefined,
    config: {},
    showHelp: false,
    showVersion: false,
    context: undefined,
    cli,
  };

  // dump command - fetch CRDs from a k8s cluster
  cli
    .command('dump [context]', 'Dump CRDs from a Kubernetes cluster')
    .option('--verbose', 'Enable verbose logging')
    .option('-o, --output-dir <path>', 'Output directory for schemas')
    .action((context, options) => {
      result.command = 'dump';
      result.context = context;
      if (options.verbose) {
        result.config.verbose = true;
      }
      if (options.outputDir) {
        result.config.outputDir = options.outputDir;
      }
    });

  // download command - fetch CRDs from configured sources
  cli
    .command('download', 'Download CRDs from configured sources')
    .option('--verbose', 'Enable verbose logging')
    .option('-o, --output-dir <path>', 'Output directory for schemas')
    .action((options) => {
      result.command = 'download';
      if (options.verbose) {
        result.config.verbose = true;
      }
      if (options.outputDir) {
        result.config.outputDir = options.outputDir;
      }
    });

  // publish command - create PR with changes
  cli
    .command('publish', 'Publish schemas to target repository via PR')
    .option('--verbose', 'Enable verbose logging')
    .option('-d, --dry-run', 'Dry run mode (do not create PRs)')
    .option('-o, --output-dir <path>', 'Output directory for schemas')
    .option('-t, --target-repo <repo>', 'Target GitHub repository')
    .option('-b, --target-branch <name>', 'Target branch')
    .action((options) => {
      result.command = 'publish';
      if (options.verbose) {
        result.config.verbose = true;
      }
      if (options.dryRun) {
        result.config.dryRun = true;
      }
      if (options.outputDir) {
        result.config.outputDir = options.outputDir;
      }
      if (options.targetRepo) {
        result.config.targetRepo = options.targetRepo;
      }
      if (options.targetBranch) {
        result.config.targetBranch = options.targetBranch;
      }
    });

  // Default/legacy command - download then optionally publish
  cli
    .command('', 'Sync CRD schemas (download and optionally publish)')
    .option('--verbose', 'Enable verbose logging')
    .option('-d, --dry-run', 'Dry run mode (do not create PRs)')
    .option('-c, --create-pr', 'Create PR on target repository')
    .option('-o, --output-dir <path>', 'Output directory for schemas')
    .option('-t, --target-repo <repo>', 'Target GitHub repository')
    .option('-b, --target-branch <name>', 'Target branch')
    .action((options) => {
      // Default command (no explicit command name)
      if (options.verbose) {
        result.config.verbose = true;
      }
      if (options.dryRun) {
        result.config.dryRun = true;
      }
      if (options.createPr) {
        result.config.createPR = true;
      }
      if (options.outputDir) {
        result.config.outputDir = options.outputDir;
      }
      if (options.targetRepo) {
        result.config.targetRepo = options.targetRepo;
      }
      if (options.targetBranch) {
        result.config.targetBranch = options.targetBranch;
      }
    });

  cli.help();
  cli.version(version);

  // Check for help/version before parsing to prevent execution
  const slicedArgs = args.slice(2);
  if (slicedArgs.includes('--help') || slicedArgs.includes('-h')) {
    cli.outputHelp();
    result.showHelp = true;
    return result;
  }
  if (slicedArgs.includes('--version') || slicedArgs.includes('-v')) {
    cli.outputVersion();
    result.showVersion = true;
    return result;
  }

  // Now parse and run with actions
  try {
    cli.parse(args, { run: true });
  } catch {
    // cac handles errors, just catch and continue
  }

  return result;
}
